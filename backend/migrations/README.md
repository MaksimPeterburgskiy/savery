# Database Migrations

This folder contains the Alembic migration scripts for the Savery backend. All
schema changes should be captured in a migration so that every environment can
be upgraded predictably.

---

## Running the First Migration

1. Ensure PostgreSQL is running and reachable via `SAVERY_DATABASE_URL`
   (defaults to `postgresql+psycopg://postgres:postgres@localhost:5432/savery`).
2. From the repository root apply the migrations:
   ```bash
   cd backend
   pip install -r requirements.txt  # first-time setup
   alembic upgrade head
   ```
   This creates all tables defined in `backend/core/schema.py` and stamps the
   database with the latest revision.

---

## Everyday Workflow

1. Update the ORM models in `backend/core/schema.py` (or other metadata-bearing
   modules) to reflect the desired schema change.
2. Generate a new migration:
   ```bash
   cd backend
   alembic revision --autogenerate -m "short description"
   ```
3. Open the generated file in `backend/migrations/versions/` and verify the
   operations. Pay special attention to:
   - JSON/Vector/PostGIS column types â€“ ensure Alembic used the correct
     `postgresql.*` types.
   - Defaults or data migrations that require manual SQL via `op.execute`.
   - Extension enablement (add `CREATE EXTENSION IF NOT EXISTS ...` when new
     dependencies are introduced).
4. Apply the migration locally to verify:
   ```bash
   cd backend
   alembic upgrade head
   ```
5. Commit both the model changes and the migration script together.

To revert the last migration during development you can run
`alembic downgrade -1`.

---

## Tracking Functions, Views, Triggers, and Policies

The tooling includes
[alembic-utils](https://github.com/olirice/alembic_utils) and
[`alembic-postgresql-enum`](https://pypi.org/project/alembic-postgresql-enum/)
so migrations cover a larger surface of PostgreSQL objects.

- Define database-side entities (functions, views, triggers, policies, etc.) in
  `backend/core/alembic_entities.py` by yielding instances such as `PGFunction`
  or `PGView` from `iter_replaceable_entities()`. They will be tracked during
  `alembic revision --autogenerate` alongside ORM changes.
- PostgreSQL enum creation and value changes are now autogenerated without
  additional manual steps.

---

## Deployment & CI Notes

- Every environment (local, CI, staging, production) must execute
  `alembic upgrade head` before launching the API or workers. In Docker-based
  deployments this usually goes into an entrypoint script or a startup job.
- CI should fail fast if migrations are missing by running `alembic upgrade
  head` against a temporary database (e.g., a disposable Postgres service).
- Avoid using `metadata.create_all()` in application code. The API startup no
  longer calls it, so the database schema is managed exclusively through
  Alembic migrations.
- For new environments, remember to provision the Postgres extensions if the
  database administrator does not allow them to be created dynamically.
- Set `SAVERY_VERIFY_SCHEMA_ON_STARTUP=true` (or configure the
  `verify_schema_on_startup` setting) when the API should refuse to start if the
  database is behind the latest Alembic head. The startup hook now verifies the
  schema before serving requests and raises a clear error when migrations are
  pending.

---

## Helpful Commands

| Task                               | Command                                   |
|------------------------------------|-------------------------------------------|
| Show current revision              | `alembic current`                         |
| List available migrations          | `alembic history`                         |
| Stamp DB (mark without executing)  | `alembic stamp head`                      |
| Autogenerate a revision (no apply) | `alembic revision --autogenerate -m ...`  |
| Downgrade one revision             | `alembic downgrade -1`                    |
| Confirm heads & scripts match      | `alembic check`                           |

Refer to the [Alembic docs](https://alembic.sqlalchemy.org/) for advanced
topics such as branching, data migrations, or offline (SQL script) generation.

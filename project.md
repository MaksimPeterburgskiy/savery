# MVP Implementation Plan for Shopping Route Optimization App

## Project Overview and MVP Scope

This project aims to build a cross-platform **Shopping Route Optimization** app that helps users save time and money on grocery trips. The core workflow: a user uploads a grocery list (items + quantities), selects nearby stores (via location or map), sets preferences (time vs cost saving, bulk vs single item pricing, etc.), and receives an optimal multi-store shopping route. The route includes which items to buy at which store, with prices and distances, and is presented as a checklist by store. For the MVP (by December), we will focus on the **critical path features**:

- **Mobile App (Expo/React Native)** for iOS/Android where users can input a list, select stores (initially limited to stores with accessible data), adjust a simple cost-vs-time slider, and view the optimized shopping plan. Web interface is lower priority (“web is last”).
- **Backend API (FastAPI)** to handle requests from the app, coordinate tasks, and serve results.
- **Data Integration** with a couple of stores (starting with those having public APIs like _Kroger_ and possibly _Walmart_) for product search and pricing. We’ll prefer official APIs when available (e.g. Kroger’s public product API[\[1\]](https://developer.kroger.com/reference/api/product-api-public#:~:text=URL%3A%20https%3A%2F%2Fdeveloper.kroger.com%2Freference%2Fapi%2Fproduct)[\[2\]](https://github.com/CupOfOwls/kroger-api#:~:text=A%20comprehensive%20Python%20client%20library,interfaces%20for%20all%20available%20endpoints)) to simplify data gathering, and use web scraping (via Playwright/Scrapy) as needed for others.
- **Background Workers (Celery + RabbitMQ)** to perform heavy tasks asynchronously – item matching (possibly using embeddings for fuzzy match) and price scraping – so the user isn’t blocked by these slow operations[\[3\]](https://realpython.com/asynchronous-tasks-with-django-and-celery/#:~:text=,requests%20to%20a%20different%20process).
- **Database (PostgreSQL)** with PostGIS for store locations and pgvector for item embeddings. This will store canonical product info, store locations, prices, and user lists. The pgvector extension lets us store & query vector embeddings for product names[\[4\]](https://severalnines.com/blog/vector-similarity-search-with-postgresqls-pgvector-a-deep-dive/#:~:text=Image%3A%20Image%20shows%20how%20vector,similarity%20search%20works), enabling semantic item matching if implemented. We’ll use the **Pint** library in Python to normalize units (e.g. lbs vs kg) so item quantities can be compared reliably[\[5\]](https://www.blog.pythonlibrary.org/2021/09/01/unit-conversion-pint/#:~:text=Do%20you%20need%20to%20work,Pint%20on%20their%20GitHub%20project).
- **Infrastructure/DevOps**: Use Docker Compose to set up a consistent dev environment with all services (DB, RabbitMQ, API, worker, etc.) configured in one file[\[6\]](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/multi-container-applications-docker-compose#:~:text=The%20docker,compose%C2%A0up). We aim to self-host everything on VPS servers (the user has access to some), including possibly a lightweight model server for embeddings (or run embedding generation within the workers). Monitoring and error tracking (Prometheus + Grafana, Sentry/Opentelemetry) are nice-to-haves for reliability, but for MVP we will at least set up basic logging and an error tracker.

**MVP Functional Scope** (September – December): We will implement the end-to-end flow with a _minimal yet functional_ feature set:

- Users can input a textual grocery list (e.g. via a text box in the app, one item per line with optional quantity/unit).
- Users can select one or multiple stores from a supported list (starting with 1-2 major chains like Kroger and Walmart within some radius of their location). For MVP, we might hard-code a few store options near a given location or allow search by zip code instead of a full interactive map if mapping is too time-consuming.
- A simple slider or toggle in the UI to prioritize “cheapest cost” vs “minimal stops/time”. (We’ll implement this as either choosing the cheapest price for each item versus limiting the number of stores visited; intermediate positions on the slider can be handled by weighting cost vs distance in the algorithm.)
- Back-end logic to take the list and preferences, **match each item to actual products** at the selected stores (initially using store product search APIs or simple name matching; later possibly refined with embeddings), **fetch current prices** for those products from each store (using API or scraping, with caching of results for ~24h), and then **compute an optimal route**. For MVP, the “optimization” can be simplified (e.g. choose the cheapest store per item and ensure the number of stores isn’t beyond what the user selected; or treat it as a variant of a Vehicle Routing Problem with Profits – not all stores need to be visited, only if savings justify it[\[7\]](https://sneharawat.medium.com/transport-logistics-route-optimization-180d7eb86f2d#:~:text=,VRPP), given the user’s time vs money preference). We will ensure the result at least shows a reasonable ordering of store visits with total cost and distance.
- Results are displayed in the app: a list of stores (in visit order) with the items to buy at each, item prices, subtotals per store, total cost, and possibly total distance. The user can then use this list as a checklist in-store. (In MVP, we’ll allow checking off items locally in the UI for convenience, without persistent user accounts.)
- Stretch (if time permits by end of semester): basic user account or saved lists, a rudimentary map route view connecting the stores, or importing a list from a recipe URL (likely as a manual step if possible). These are optional; the core MVP is the multi-store list optimization.

## Team Roles and Responsibilities

We have **4 developers** on this project, each with different strengths. Below is a breakdown of each developer’s role, primary responsibilities, and planned tasks throughout the semester:

### Developer 1 – _DevOps & Backend Lead_ (Comfortable with DevOps)

**Role & Focus:** Developer 1 will act as the team lead for backend and infrastructure. They will set up the project architecture (both backend and frontend skeletons), manage devops (CI/CD, Docker, deployment), and coordinate integration between components. They will also tackle complex backend tasks like integrating the embeddings model and ensuring the system components (API, workers, DB, etc.) work together smoothly.

**Planned Tasks:**  
- _Initial Project Setup (Week 1-2):_ Set up the monorepo on GitHub with a clear **project layout** (see “Project Repository Layout” below). Configure Docker Compose to run PostgreSQL, RabbitMQ, the FastAPI app, and a Celery worker in containers for easy development and testing[\[6\]](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/multi-container-applications-docker-compose#:~:text=The%20docker,compose%C2%A0up). Create a basic FastAPI project structure (with an /api route ready) and an Expo app initialized (via npx create-expo-app). Establish CI workflows (GitHub Actions) for linting/tests and possibly CD for deploying backend to the VPS.  
- _Architecture & Stack Decisions:_ Implement and document integration of **PostGIS** (for store location queries) and **pgvector** in Postgres (for future embedding-based search)[\[4\]](https://severalnines.com/blog/vector-similarity-search-with-postgresqls-pgvector-a-deep-dive/#:~:text=Image%3A%20Image%20shows%20how%20vector,similarity%20search%20works). Ensure the database is seeded with essential data (e.g., a few store locations and their IDs for the APIs). Set up environment variables/secrets management for API keys (Kroger API, etc.). If using a self-hosted embedding model, set up a lightweight model server or plan to run it within Celery tasks (e.g., using [SentenceTransformers](https://www.sbert.net/) for product name embeddings).  
- _Backend Core Development:_ Implement the FastAPI endpoints and core logic in coordination with Devs 2 and 3. For example, an endpoint POST /optimize that accepts the shopping list, selected store IDs, and user preferences. This handler will enqueue background tasks (via Celery) to perform item matching and price retrieval. Developer 1 will write or supervise writing of the Celery tasks: one for **item matching** (taking each list item and finding the best matching actual product(s)), and one for **route optimization** (taking matched products with their prices to decide the best store distribution). Ensure RabbitMQ is properly configured as the message broker for Celery and results can be tracked (possibly use a results backend or have Celery store results in the database). They will also help integrate **WebSockets** or server-sent events in FastAPI to push task progress/results to the frontend in real-time, so the mobile app can show a loading/progress state or update when the route is ready.  
- _DevOps & Deployment:_ Automate the setup of dev and prod environments. Write scripts or docs for setting up the VPS servers (installing Docker, running the compose stack in production). Configure monitoring: e.g., set up **Grafana/Prometheus** to watch basic metrics (container CPU/mem, task runtimes) and **Sentry** for error reporting (integrate Sentry SDK in both FastAPI and React Native for crash logging). This can be done mid-semester after core features are underway.  
- _Support & Code Review:_ Guide Dev 2 and 3 (novice developers) in following best practices for Python (using Pydantic models for request/response, writing clear functions for scraping, etc.). Perform code reviews and help troubleshoot integration issues (e.g., CORS issues between app and API, or data format mismatches).  
- _Embedding Model Integration:_ If pursuing the embedding approach for item matching, Dev 1 will take charge of this complex feature. Likely in late October, experiment with a small embedding model to match generic vs specific product names (e.g., using OpenAI API or a local model). Integrate **pgvector** usage: e.g., store vector for each known product in the DB and use a similarity search query to find close matches for a given item name[\[4\]](https://severalnines.com/blog/vector-similarity-search-with-postgresqls-pgvector-a-deep-dive/#:~:text=Image%3A%20Image%20shows%20how%20vector,similarity%20search%20works). (If time is short, this can be simplified to keyword matching for MVP, with a plan to refine later.) Also, incorporate the **Pint** library so that units in the user’s query (like "2 lb carrots") can be normalized and compared to units in product info (like price per pound)[\[5\]](https://www.blog.pythonlibrary.org/2021/09/01/unit-conversion-pint/#:~:text=Do%20you%20need%20to%20work,Pint%20on%20their%20GitHub%20project)[\[8\]](https://www.blog.pythonlibrary.org/2021/09/01/unit-conversion-pint/#:~:text=One%20of%20Pint%E2%80%99s%20cool%20features,can%20do%20stuff%20like%20this).  
- _Final Integration & Deployment (Nov–Dec):_ Ensure that by end of November, all pieces (UI, API, tasks, DB) are integrated. Conduct end-to-end testing with various sample lists and store combinations. Fix any deployment issues on the server (e.g., scaling workers, handling errors gracefully). Make sure documentation is complete (especially the README for running the project, and any devops scripts). Prepare the app for RCOS final demo (maybe populate it with some demo data for a smooth presentation).

### Developer 2 – _Backend & Data (Novice)_

**Role & Focus:** Developer 2 will focus on backend features under guidance from Dev 1, particularly on **data sourcing and integration**. They will work on implementing store-specific data providers (e.g., using Kroger’s API or writing a scraper for Walmart), and help build the product matching and pricing logic. This gives exposure to web scraping, REST APIs, and databases – good learning for a novice.

**Planned Tasks:**  
- _API & DB Foundations (Week 2-3):_ Collaborate with Dev 1 to design the database schema. Define models like Store (with id, name, location coordinates), Product (canonical representation of an item, possibly with a normalized name and category), StoreProduct or PriceEntry (mapping a product to a specific store with price, last_fetched timestamp, etc.), and perhaps ShoppingList/ListItem to store user list entries (if we persist lists). Developer 2 will write SQLAlchemy models or use an ORM (if FastAPI with Pydantic + SQLAlchemy or Tortoise). They will also set up **pgvector** extension on the DB (with Dev 1) to ensure we can store embeddings for products.  
- _Kroger API Integration (Week 3-5):_ Take lead on integrating the **Kroger Products API**. Register for an API key (Public Product API has 10k calls/day limit) and implement a Python client (possibly using an existing library like kroger-api[\[2\]](https://github.com/CupOfOwls/kroger-api#:~:text=A%20comprehensive%20Python%20client%20library,interfaces%20for%20all%20available%20endpoints) or simple requests calls). Write a function or Celery task that given a search term (item name) and a store location or ID, queries the Kroger API to get matching products. Parse the response to extract relevant fields: product name, size/quantity, price (regular and promo)[\[9\]](https://developer-ce.kroger.com/documentation/api-products/public/products/overview#:~:text=The%20Products%20API%20allows%20you,promo%20price%20of%20the%20item)[\[10\]](https://documenter.getpostman.com/view/4833726/TVReeWJm#:~:text=Kroger%20Public%20APIs%20Products,com%2Fv1%2Fproducts). Ensure this can handle generic items (e.g., “milk” returns a list of milk products). Developer 2 will also create a utility to pick the “best match” from the results – for MVP, perhaps the first result or lowest price among results, and store that in the DB. This forms the backbone of item matching for stores with APIs.  
- _Walmart Data Integration (Week 5-7):_ Since Walmart doesn’t have an open public API for prices[\[11\]](https://scrapfly.io/blog/posts/guide-to-walmart-api#:~:text=In,as%20long%20as%20product)[\[12\]](https://www.reddit.com/r/learnprogramming/comments/1hmztg3/does_walmarts_api_allows_realtime_access_to_store/#:~:text=Does%20Walmart%27s%20API%20allows%20real,item%20listed%20as%20%E2%80%9Cin), Developer 2 can explore alternatives: for MVP, possibly use the Walmart website via scraping or use a third-party API wrapper. They could utilize **Playwright** to simulate a search on walmart.com for a product and scrape the first result’s price, or use a service like SerpApi for Walmart (but that might be against open-source spirit due to API keys/cost). The plan is to implement a **scraper task** that given an item name and a store/zipcode, it fetches the price. Developer 2 will write a Celery task for Walmart product search scraping (ensuring it runs headless and parses HTML for product title and price). Given the time constraints, we might limit Walmart support to a few item categories for demo purposes.  
- _Item-Price Database Updates:_ For both Kroger and Walmart (or any provider), Developer 2 will implement logic to store the fetched product info in the DB. For example, when an item “Peanut butter” is matched to Kroger’s product “Jif Crunchy Peanut Butter 16oz”, save a Product entry (if not exists) and a PriceEntry for Kroger with price $X. We’ll record a timestamp to allow re-use of recent data. If a price is older than 24 hours when needed, a new scrape/API call will be triggered to update it. Developer 2 will also help ensure that if multiple users request overlapping items, we reuse the data (so one scrape can serve all – perhaps by querying DB first before calling external sources).  
- _API Endpoints & Business Logic:_ Work with Dev 1 to implement parts of the FastAPI endpoints, especially the sections that assemble the data. For instance, after Celery returns matched products and prices, the API needs to compile the response for the app: which store to go to for each item. Developer 2 can write helper functions to choose the cheapest store for each item or apply the user’s cost/time preference (e.g., if user prioritizes cost, choose the absolute cheapest per item; if prioritizing time, maybe constrain to fewer stores even if some items cost slightly more). We can start with a simple greedy algorithm for MVP. The more complex _optimization_ (minimizing total travel vs cost) can be gradually improved; Developer 2 will implement a basic version and leave hooks for future improvement.  
- _Testing & Refinement:_ Throughout November, Developer 2 will test the data pipeline: input -> match -> price -> output. They should write unit tests for functions like “match_item_to_product” (with sample inputs to verify that, say, “organic roma tomato” matches a tomato product and not something else). They will also test the scraper functions independently. Any bugs (e.g., parsing failures, API edge cases) should be fixed. They can also generate a small **sample dataset** (maybe a JSON of 10 common items with their prices at Kroger/Walmart) to use as fallback if live calls fail during demo.  
- _Stretch Task:_ If time permits after core features, Developer 2 could look into adding **one more data source** (for example, another regional grocery chain with a simple HTML site) or implementing a simple **inventory check** (like assume in-stock if price found, otherwise note “item not found”). These are secondary; the primary goal is robust price fetching for the two main stores.

### Developer 3 – _Backend & Algorithm (Novice)_

**Role & Focus:** Developer 3, also a novice, will work closely with Developer 2 on the backend but with a focus on the **matching logic, algorithms, and additional services**. They will handle tasks like unit conversion and normalization (so our system understands “3 bananas” vs “1 lb bananas”), assist with the route optimization algorithm, and possibly set up auxiliary services like the mapping or location retrieval. Developer 3 will also create any necessary _workers_ for tasks such as periodic scraping or cleanup.

**Planned Tasks:**  
- _Unit Normalization & Item Parsing:_ Early on (Week 2-4), Developer 3 will research and implement how to parse the user’s input list. Using **Pint** (the Python units library), they will create a function that can interpret strings like "2 lb chicken" or "500g flour" and convert them into a standard unit (e.g., grams or pounds) for comparison[\[8\]](https://www.blog.pythonlibrary.org/2021/09/01/unit-conversion-pint/#:~:text=One%20of%20Pint%E2%80%99s%20cool%20features,can%20do%20stuff%20like%20this). Similarly, handle counts (like “3 bananas” might be treated as 3 units, vs “2 bunches of cilantro”). This will feed into the matching – e.g., if a store sells bananas by weight, our system might estimate 3 bananas ~1 lb for price calculation. Developer 3 will also help define how to store quantity in the data model (we could store as a float amount + unit).  
- _Embedding Model & Fallback Matching:_ If we pursue embeddings, Developer 3 will assist Developer 1 in setting up the model usage. For example, writing a function generate_embedding(item_name) that calls a local model or API to get a vector, and another function to query the pgvector index for similar product names[\[4\]](https://severalnines.com/blog/vector-similarity-search-with-postgresqls-pgvector-a-deep-dive/#:~:text=Image%3A%20Image%20shows%20how%20vector,similarity%20search%20works). They can start with simpler fuzzy matching (e.g., case-insensitive substring matching, or using Python libraries like RapidFuzz for string similarity) as an initial solution, then compare it against an embedding approach for accuracy. Developer 3 will also prepare a **UPC or product database** lookup as a backup – e.g., using Open Food Facts or similar open datasets if available, to identify a product’s UPC by name (this might not be fully implemented in MVP, but they can do preliminary research).  
- _Route Optimization Algorithm:_ One of Developer 3’s key tasks (Week 6-8) is formulating the shopping route optimization. Initially, they can implement a **greedy algorithm**: assign each item to the store with the lowest price (subject to user’s selected stores), then compile the unique set of stores that covers all items. If the user’s _time-saving_ preference is high, we might limit the number of stores (for example, if an item’s cheapest store is a lone outlier, maybe choose the second-cheapest if it avoids adding a new stop). Developer 3 will implement logic to adjust this based on a “cost vs time” parameter (e.g., a simple weight: total_cost + α \* number_of_stores or total_drive_distance, and try to minimize that). This is effectively a simpler form of the **Vehicle Routing Problem with Profits (VRPP)** – we don’t have to visit every store, only those that yield enough savings[\[7\]](https://sneharawat.medium.com/transport-logistics-route-optimization-180d7eb86f2d#:~:text=,VRPP). For MVP, an exact algorithm isn’t required; a heuristic or brute-force over the small set of selected stores will do (e.g., if user picks at most 3 stores, try all combinations of assigning items to those stores and pick best). Developer 3 will code this in the Celery task that runs after price collection. They’ll also incorporate distance data: perhaps use the Haversine formula via store coordinates (since we have PostGIS, we can query distances between store locations and the user’s location) – or simply use Google Maps API if allowed (likely not needed for MVP, approximate distances are fine).  
- _Map and Location Services:_ Developer 3 can assist Developer 4 with the map functionality. For example, they can write a small endpoint in FastAPI to return nearby stores given a user’s location (if we populate the DB with store locations). They could use the **PostGIS** ST_DWithin query to find stores within X miles of a lat-long. Additionally, they might pre-load some store coordinates using external data (Kroger’s **Location API** can provide store locations by zip code[\[13\]](https://developer.kroger.com/reference/api/location-api-public#:~:text=Location%20API%20,Locations%20API%20has%20a), which Developer 3 can use to populate our Store table for the region around Troy, NY as a starting point). For the route map, Developer 3 can help by calculating an ordered list of store coordinates for the optimal route and returning it to the frontend, so the frontend can plot polylines if desired.  
- _Testing & Improvement:_ Through November, Developer 3 will test the optimization with various scenarios (e.g., all items cheapest at one store vs split scenarios) to ensure the algorithm respects the slider preferences. They will also verify unit conversions (e.g., if a user asks for 2 lbs of something and one store sells a 1.5 lb package, does our cost calculation handle partial units or suggest buying two packages?). Any edge cases (like item not found in any store) should result in a clear output (perhaps listing those items as “unmatched”). Developer 3 should implement fallback behavior for unmatched items – e.g., flag them so the frontend can inform the user that those items need manual attention.  
- _Stretch Task:_ If time allows, Developer 3 might start a very basic **scheduler** to keep price data fresh. For example, a daily Celery Beat task that triggers scraping updates for popular items or a maintenance script to clean old data. This would ensure that over time, as more items are searched, the database becomes more populated. However, this is optional and can be deferred if the core features take all the time.

### Developer 4 – _Frontend & UI/UX (Enthusiastic about UI)_

**Role & Focus:** Developer 4 will concentrate on building the **Expo/React Native app** UI, leveraging their enthusiasm for UI/UX. They will implement all the screens and components, integrate the **Expo Router** for navigation, and use the **React Native Reusables** component library for a consistent design[\[14\]](https://github.com/founded-labs/react-native-reusables#:~:text=Bringing%20shadcn%2Fui%20to%20React%20Native,almost%20as%20easy%20to%20use). Developer 4 will also handle integrating the frontend with the backend API (using REST calls and WebSocket for updates) and ensure the app provides a smooth user experience (loading states, error messages, etc.).

**Planned Tasks:**  
- _UI Design & Architecture (Week 1-3):_ Start by defining the overall app structure using **Expo Router**. Expo Router allows file-system based navigation for native apps, similar to Next.js for web, and works across Android, iOS, and web[\[15\]](https://docs.expo.dev/router/introduction/#:~:text=). Developer 4 will set up basic route files: e.g., app/index.tsx for the Home/List Input screen, app/stores.tsx for store selection, app/options.tsx for preferences (if separate), app/results.tsx for the route results, and maybe app/confirm.tsx for item confirmation step. Using React Native Reusables, they can quickly scaffold UI components (buttons, inputs, sliders, etc.) with a modern design system (shadcn/ui on native)[\[14\]](https://github.com/founded-labs/react-native-reusables#:~:text=Bringing%20shadcn%2Fui%20to%20React%20Native,almost%20as%20easy%20to%20use). They will collaborate with the team to create a simple, clean UX: perhaps a multi-step form wizard or a scrollable single page – but likely multi-screen for clarity. Sketching some wireframes or low-fidelity mockups in the first week will help align everyone.  
- _List Input Screen:_ Implement the first screen where the user enters their shopping list. This could be a text textarea where each line is an item (with quantity), or a dynamic list where they press “Add item” repeatedly. For MVP, a textarea might be simplest (user writes e.g. “2 lb chicken breast\\n1 gallon milk\\n3 bananas”). Developer 4 will create this component and include helpful UI elements (maybe an example placeholder text, or the ability to scan text from an image as a stretch). They’ll add a **submit button** that navigates to the next step with the entered list data.  
- _Store Selection Screen:_ After entering the list, the user needs to pick stores. Developer 4 will implement a screen that shows either a map with store pins or a list of stores. Considering time, a quick approach is a list of nearby store names with checkboxes. If implementing a map: use a React Native map library (e.g., react-native-maps or Expo’s MapView) to show user’s location and nearby stores (fetched via an API call to our backend or using a static list). The user can tap to select one or multiple stores. Each store might have a marker icon (e.g., Kroger, Walmart logos). Developer 4 needs to handle permission for location access if using GPS. For MVP simplicity, we might ask the user to enter their ZIP code or city and just list stores around there (to avoid too much map work). Either way, they’ll provide a UI for selecting at least one store (with a limit or warning if too many are picked).  
- _Preferences UI:_ Incorporate a **slider** component for the “Time vs Money Savings” preference. For example, a slider ranging from “Max Time Save (fewest stores)” on one end to “Max Money Save (lowest prices)” on the other. The selected value can be passed as a numeric weight to the backend. Also, include a toggle for “allow bulk buying more than needed to save per unit” vs “exact amounts only” if possible. This might be a simple switch labeled “Allow bulk substitutions”. Developer 4 will use appropriate components from Reusables (like slider, switch) and ensure they are intuitive. These preferences can be on the same screen as store selection or a separate screen; likely on the same page for simplicity (store list + preferences below).  
- _Submitting & Waiting UX:_ When the user hits “Submit” after choosing stores and options, Developer 4 will make a POST request to the FastAPI endpoint (e.g., using fetch or Axios). They will then show a **loading state** – perhaps a status screen that updates the user: “Matching items to products…”, “Fetching latest prices…”, “Calculating optimal route…”. If we implement WebSocket updates, Developer 4 will connect to a WebSocket endpoint (FastAPI can serve one) that sends messages like {stage: "matching", progress: 5/10}, etc. They can display a progress bar or spinner with these messages. If WebSockets are too complex for MVP, they can simply poll the API periodically for task status. Ensuring the user doesn’t see a frozen screen is key.  
- _Results Screen:_ Developer 4 will display the final optimized shopping plan in a clear format. For example: a heading for each store in the route order (with store name, address, maybe an icon), under each a list of items to buy there (quantity, name, price). At the bottom or top, show total cost and total estimated distance/time. They should make this view scrollable and readable. Each item can have a checkbox that the user can tick off (maintained in local state, since we may not persist this). If possible, highlight the cheapest items (or savings) in some way. Also include a button like “Re-run with different settings” or “Back to list” to allow the user to tweak inputs.  
- _Polish & Testing:_ Through November, Developer 4 will refine the UI: use consistent styling (possibly configure **NativeWind** with a Tailwind config as React Native Reusables suggests[\[14\]](https://github.com/founded-labs/react-native-reusables#:~:text=Bringing%20shadcn%2Fui%20to%20React%20Native,almost%20as%20easy%20to%20use)). Ensure it looks good on both Android and iOS screen sizes. They should test the app on a physical device or emulator weekly, because styling can differ. Also handle error cases: e.g., if the backend returns an error or times out, show an alert with a friendly message (“Sorry, we couldn’t find any matches for ‘X’. Please revise your list.”). If an item is unmatched, maybe mark it in the results (e.g., show it under a “Not found” section).  
- _Collaboration:_ Work with Dev 3 on mapping – if we want to show the driving route on the results screen, Developer 4 can use a polyline on the MapView. Dev 3 can provide the ordered coordinates. If short on time, skip the route map and just trust text distances. Work with Dev 1 on integrating Sentry for the React Native app to catch crashes. Also possibly set up OTA updates using Expo EAS if we want to push updates quickly during testing (not mandatory for MVP demo).  
- _Final Touches:_ In the last two weeks, Developer 4 will ensure the app is **production build ready** – test a release mode build, fix any slow performance (like large list handling), and prepare the app’s visuals for demo (maybe include an app icon, a simple logo/title on the home screen). They will also update the project README with instructions on how to run the app (Expo development server, etc.), so others (like RCOS mentors or open-source contributors) can try it easily.

## Project Repository Layout

We will use a **monorepo** (single repository) on GitHub to house both the frontend and backend, facilitating easy issue tracking and PRs in one place. Below is the proposed structure:

shopping-route-optimizer/ (Root of the GitHub repo)  
├── frontend/ (Expo React Native app)  
│ ├── app/ (Expo Router pages directory)  
│ │ ├── \_layout.tsx (Router layout, if using nested routes)  
│ │ ├── index.tsx (Home screen – list input)  
│ │ ├── stores.tsx (Store selection & preferences screen)  
│ │ ├── results.tsx (Results/route display screen)  
│ │ └── \[other screens\].tsx (Additional screens if needed, e.g., confirm matches)  
│ ├── components/ (Reusable UI components, e.g., custom list item component)  
│ ├── hooks/ (custom hooks for data fetching, maybe useWebSocket)  
│ ├── assets/ (images, icons, etc. e.g., store logos)  
│ ├── package.json  
│ └── \*\*...\*\* (other config files like babel, tsconfig, etc.)  
├── backend/ (FastAPI backend)  
│ ├── app/  
│ │ ├── main.py (FastAPI app creation, including API routes and WS routes)  
│ │ ├── api/ (API route definitions)  
│ │ │ ├── routes.py (defines /optimize endpoint, etc.)  
│ │ └── models.py (Pydantic models for request/response)  
│ ├── core/ (Core modules)  
│ │ ├── db.py (database connection setup, e.g., SQLAlchemy session)  
│ │ ├── schema.py (SQLAlchemy models for Store, Product, Price, etc.)  
│ │ ├── tasks.py (Celery app init and task definitions)  
│ │ └── config.py (configuration, constants)  
│ ├── workers/ (Celery worker related code if separate)  
│ │ ├── scraping.py (functions to scrape or call APIs for prices)  
│ │ ├── matching.py (item matching logic, maybe using embeddings)  
│ │ └── optimize.py (route optimization algorithm)  
│ ├── tests/ (Test cases for backend functions)  
│ └── requirements.txt (Python dependencies)  
├── infrastructure/ (DevOps configs)  
│ ├── docker-compose.yml (Compose file to run services together\[6\])  
│ ├── Dockerfile.api (Dockerfile for FastAPI service)  
│ ├── Dockerfile.worker (Dockerfile for Celery worker)  
│ ├── Dockerfile.frontend (if we containerize Metro bundler or use Expo image)  
│ └── k8s/ or deploy/ (optional: config for deployment, if using Kubernetes or others in future)  
├── README.md (Project overview, setup instructions)  
└── .github/  
├── workflows/ci.yml (CI pipeline: lint, test)  
└── ISSUE_TEMPLATE.md (templates for issues/PRs if desired)

**Note:** We keep frontend and backend in separate subfolders but one repo for simplicity. The docker-compose.yml will define services: e.g., api (uses Dockerfile.api), worker (uses Dockerfile.worker), db (postgres image with PostGIS), queue (RabbitMQ image), and maybe a vector_db if we needed something special (but pgvector is an extension within Postgres). This allows any developer to run docker-compose up and have a full environment locally[\[6\]](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/multi-container-applications-docker-compose#:~:text=The%20docker,compose%C2%A0up). For development, developers can also run services directly (e.g., run FastAPI with Uvicorn on host for easier debugging, run Celery locally, etc., connecting to the Docker DB and RabbitMQ).

We will use **Git branches** for features. Each developer should work on their features in separate branches (e.g., feature/kroger-api, feature/ui-screens etc.) and open Pull Requests for review. Dev 1 (or others) will review and merge into main. This process ensures code quality and knowledge sharing (especially helpful since Dev 2 and 3 are novices – PR reviews will be teaching moments). We’ll also enforce some coding standards via linters/formats: e.g., Prettier for JS/TS, Flake8 or Black for Python. These can be run in CI.

Documentation will live in the README and possibly a docs/ folder for detailed design notes (like explaining the algorithm, data model, etc., for the open-source community). We will also keep **issues** to track tasks and bugs, which aligns with the breakdown above.

## Timeline & Milestones

Below is a rough **timeline from now (mid-September) to December**, aligning with the semester. Each milestone highlights key goals and who’s responsible:

- **Week 1-2 (Mid/Late September)** – _Project Initialization & Planning:_
- All devs: Finalize the tech stack choices and MVP scope (as outlined). Clarify any unknowns (e.g., confirm Kroger API access, decide on mapping approach).
- Dev 1: Set up repo, Docker Compose env, base FastAPI app and Expo app. Push a “hello world” for both backend (e.g., a /ping endpoint) and frontend (a simple screen) to ensure the pipeline works.
- Dev 4: Implement the basic navigation structure with dummy screens (so we can navigate from list input -> store select -> results, even with static data initially). Start designing UI components using React Native Reusables[\[14\]](https://github.com/founded-labs/react-native-reusables#:~:text=Bringing%20shadcn%2Fui%20to%20React%20Native,almost%20as%20easy%20to%20use).
- Dev 2 & 3: Begin work on data layer – create the database schema and models for products and stores. Dev 2 to register for Kroger API key and try a sample product search call (outside the app) to familiarize with the data format. Dev 3 to test Pint library usage for units.
- **Deliverable:** A project skeleton in GitHub – everyone can run the app (even if it just shows dummy screens), and the backend (even if just health-check endpoints). Also, a brief design doc or MD notes in repo describing the planned architecture.
- **Week 3-5 (Early October to Mid October)** – _Core Features Development:_
- Dev 4: Complete the **List Input** and **Store Selection** UI screens. Implement form handling and navigation between them. The UI should allow inputting a list and choosing stores (for now, the store list can be hardcoded or fetched from a static JSON of 2-3 stores for testing).
- Dev 1 & Dev 2: Implement the /optimize API endpoint (or separate endpoints like /match and /route if we break it down). When called, this endpoint should initiate Celery tasks for item matching. Use a placeholder implementation that simply returns a dummy route result after a few seconds (to test the async flow). Integrate Celery and RabbitMQ in the backend – ensure tasks can be dispatched and received. Developer 1 might implement a simple task that just waits 3 seconds and returns a canned result for now.
- Dev 2: Flesh out the **Kroger API** integration. By week 5, we should be able to input “milk” and get actual price info from Kroger’s API for a given store. Integrate this into a Celery task fetch_prices_kroger(item, store_id).
- Dev 3: Work on the **matching logic** – for now, maybe just use the Kroger API search as the matching (i.e., assume the first result is the intended item). Also begin coding the **optimization heuristic** (e.g., assign all items to the first store as a trivial solution, we will refine later). Dev 3 also to set up the PostGIS extension and verify a simple location query (for later use).
- Dev 1: Assist others, integrate components. Set up a **WebSocket or polling** mechanism: maybe an endpoint /status/{task_id} to check if the result is ready, which the frontend can poll. Alternatively, configure a simple WebSocket in FastAPI to broadcast when done. Dev 1 should also containerize the backend and worker so others can use the same environment.
- **Mid-Semester Check (around mid-Oct):** At this point, aim to have a **demo-able prototype** for RCOS midterm evaluation. The demo scenario: The user inputs a small list (e.g., 2 items), selects Kroger, hits submit, and after a short wait sees a result with those items priced at Kroger. Even if the optimization is trivial (one store), this proves the end-to-end flow. We’ll explain that multi-store logic is coming. If possible, include Walmart in a basic way (even if using a mocked price).
- **Deliverable:** Midterm demo + code: The app can show results from live data for one store. Documentation updated (setup instructions, maybe a short midterm report on what’s done and what’s next).
- **Week 6-8 (Late October – Early November)** – _Multi-Store & Optimization:_
- Dev 2: Finalize **Walmart scraping** integration. Ensure that for a given query we can get a price from Walmart (even if not 100% reliable, cover common items). Possibly use a headless browser with a timeout. Integrate this into the task flow so that if Walmart is among selected stores, prices are fetched from Walmart as well.
- Dev 3: Implement the **full optimization algorithm**. Now that we can get prices from multiple stores, write logic to decide which store each item should be bought from. For MVP, a simple strategy: for each item, find the cheapest price among chosen stores; then determine the unique store set and order them. If the slider is tilted towards time-savings, perhaps limit to the cheapest _single_ store (if difference is small) or cheapest two stores only. Developer 3 can incorporate distance by sorting the stores by distance from user’s location (start at nearest store, etc.). This is the stage to refine the balancing act between cost and time. We might even implement two modes: “cheapest overall” vs “fewest stores” as discrete options if slider continuum is tricky.
- Dev 4: Build the **Results screen** to display multiple stores. Dev 4 should now use real data coming from the API (Dev 1/2/3 will provide an endpoint response format). They will parse that and render a nice output. Add the ability to check off items (just local state toggling a checkbox component next to each item). Possibly add a refresh or back option to restart. Also ensure that if the user selected multiple stores, the UI clearly separates items by store. If there’s any indication of route order (like numbering stores or showing distance between them), include that in the design.
- Dev 1: Connect the frontend to backend fully. Adjust CORS settings so the Expo app (on device or emulator) can talk to the local dev server or deployed server. Implement any remaining pieces in the backend: e.g., if tasks are chained (match items task -> then optimization task), set that up with Celery workflows. Also, implement caching: e.g., before calling an external API for a price, check if our DB has a recent price. This can be done within the Celery task by Dev 1 or 2.
- Testing as a group: By early November, we want the multi-store scenario working. For example: input “milk, eggs, bread”, select Kroger + Walmart, and get a result that maybe says “Go to Walmart for bread (cheapest), Kroger for milk and eggs” or vice versa, along with cost breakdown. The team should test with different inputs and ensure no obvious crashes. This is also a good time to get **feedback** – maybe have a couple of friends or mentors run the app and give impressions on the UI/UX and results accuracy.
- **Deliverable:** A **feature-complete MVP** by end of Week 8. All primary user stories can be executed. From here on, it’s about polish, performance, and fixing bugs.
- **Week 9-11 (Mid November – Early December)** – _Polish, Testing, and Documentation:_
- Dev 4: **UI/UX Polish** – refine styling details, add any branding (for RCOS presentation, maybe an app name and simple logo). Ensure the app is accessible (text not too small, colors clear). Implement any remaining nice-to-haves that are quick: e.g., allow editing the list after seeing results (maybe let the user go back and adjust quantities), or a confirmation screen after item matching (if we have ambiguity, but that might be complex for MVP – we might skip explicit confirmation due to time).
- Dev 2 & 3: **Performance and Reliability** – Improve error handling in the backend. For example, if a store’s API fails or a scraper times out, ensure the Celery task doesn’t crash silently; it should mark that item/store as unavailable and continue. Maybe implement retries for scraping. Also, consider thread-safety: if many tasks run, will the external calls exceed rate limits? For MVP with few users it’s fine. They should also ensure the database queries (especially any using pgvector similarity or PostGIS location) have proper indexes and are efficient. Write additional tests for complex logic (algorithm test: if one store is significantly cheaper for all items, ensure the result picks that store, etc.).
- Dev 1: **Monitoring & Deployment** – Set up the live environment on the VPS if not already. Deploy the database (with extensions), RabbitMQ, etc. Possibly use Docker Compose on the server as well for simplicity. Configure domain or IP for the API and ensure the app can reach it. Implement **Prometheus exporters** for Python or use Docker metrics to watch memory (so Celery doesn’t leak). Integrate Sentry for both backend and frontend and test an intentional error to see if it’s reported[\[3\]](https://realpython.com/asynchronous-tasks-with-django-and-celery/#:~:text=,requests%20to%20a%20different%20process) (this will help catch any runtime exceptions during actual usage). Also, ensure that the open-source repo is tidy: include a good README, contributors, license info, and maybe some screenshots of the app in action for the documentation.
- **Buffer & Stretch:** We have a small buffer if things run behind. If ahead of schedule, possible stretch tasks:
  - Implement **user accounts** with Auth0 or simple JWT (not required for MVP since an individual can use it without login, but accounts would let people save preferences or lists).
  - **Recipe import**: allow user to paste a URL from a recipe and parse ingredients into the list (this could use an external recipe parser API if time allows).
  - **In-store navigation**: purely brainstorming for future – definitely out of scope for MVP, but Dev 3 can research if any stores provide aisle info via API for future plans.
  - **Web App**: If time, Dev 4 could ensure the Expo app runs on web (Expo Web can produce a web build). Not critical for now, but having it partially working on web could be nice.
- During this phase, ensure all **RCOS requirements** are met: likely writing a final report, preparing presentation slides, and doing a video demo if required. Each dev might need to write a reflection or blog post – plan these into the schedule so they don’t get overlooked.
- **Week 12 (Mid December)** – _Final Delivery:_
- Conduct final full testing and quality checks. Make sure the app performs reasonably on a real device (no glaring slowdowns or crashes). Ensure that _all citations and attributions_ for open-source components are in order (for RCOS and licensing compliance).
- The team will do the **final presentation** showcasing the MVP. Likely, one scenario will be demonstrated live: e.g., “Imagine I have a list and I want to shop at Walmart and Kroger, here’s how our app optimizes my trip.” Have that polished and rehearsed.
- After presentation, we’ll officially release the code as open source (if not already public) – perhaps tag a v1.0.0 on GitHub. Possibly deploy a live demo instance if feasible (so others can test using a REST client or the app via Expo).
- **Deliverable:** Final project submission to the class: code, documentation, and a live demo.

Throughout the project, we will maintain regular team meetings (at least weekly, as 4 hours/week per developer is expected). These meetings will serve to sync progress, resolve blockers, and adjust the plan as needed. Given the detailed breakdown above, each developer knows their focus, but we will work collaboratively – e.g., pair programming when a novice needs help, or Dev 1 switching to assist UI if needed. The plan is meant to be a guide; we’ll stay agile and adapt if certain tasks take more or less time than expected.

## References and Acknowledgments

- Expo and React Native documentation for guiding the app setup and routing (Expo Router allows cross-platform file-based navigation[\[15\]](https://docs.expo.dev/router/introduction/#:~:text=)).
- React Native Reusables library for pre-built UI components (provides a consistent design system based on shadcn/UI and NativeWind[\[14\]](https://github.com/founded-labs/react-native-reusables#:~:text=Bringing%20shadcn%2Fui%20to%20React%20Native,almost%20as%20easy%20to%20use)).
- Kroger Public API for product search and pricing (10,000 calls/day; will be used for initial store integration)[\[2\]](https://github.com/CupOfOwls/kroger-api#:~:text=A%20comprehensive%20Python%20client%20library,interfaces%20for%20all%20available%20endpoints).
- Postgres enhancements: PostGIS for geospatial queries and pgvector for vector similarity search (to enable AI-driven product matching)[\[4\]](https://severalnines.com/blog/vector-similarity-search-with-postgresqls-pgvector-a-deep-dive/#:~:text=Image%3A%20Image%20shows%20how%20vector,similarity%20search%20works).
- Pint library for Python to handle unit conversions in parsing quantities (helps interpret “lbs”, “oz”, etc., seamlessly in code)[\[5\]](https://www.blog.pythonlibrary.org/2021/09/01/unit-conversion-pint/#:~:text=Do%20you%20need%20to%20work,Pint%20on%20their%20GitHub%20project).
- Celery with RabbitMQ for asynchronous task processing, ensuring tasks like web scraping don’t block the main app[\[3\]](https://realpython.com/asynchronous-tasks-with-django-and-celery/#:~:text=,requests%20to%20a%20different%20process). This lets us fetch data and compute routes in the background, improving the app’s responsiveness.
- Vehicle Routing Problem research as inspiration for our optimization algorithm, particularly the VRP with Profits variant where not all locations (stores) must be visited – we only stop at stores that give overall benefit[\[7\]](https://sneharawat.medium.com/transport-logistics-route-optimization-180d7eb86f2d#:~:text=,VRPP).

We believe this plan covers the implementation in a comprehensive manner and assigns clear ownership to each team member. By following this schedule and actively communicating, the team should deliver a functional MVP by December that meets the requirements of the open-source project and provides a foundation for future enhancements. Let’s get started!

[\[1\]](https://developer.kroger.com/reference/api/product-api-public#:~:text=URL%3A%20https%3A%2F%2Fdeveloper.kroger.com%2Freference%2Fapi%2Fproduct) developer.kroger.com

<https://developer.kroger.com/reference/api/product-api-public>

[\[2\]](https://github.com/CupOfOwls/kroger-api#:~:text=A%20comprehensive%20Python%20client%20library,interfaces%20for%20all%20available%20endpoints) GitHub - CupOfOwls/kroger-api: A comprehensive Python client library for the Kroger Public API, featuring robust token management, comprehensive examples, and easy-to-use interfaces for all available endpoints.

<https://github.com/CupOfOwls/kroger-api>

[\[3\]](https://realpython.com/asynchronous-tasks-with-django-and-celery/#:~:text=,requests%20to%20a%20different%20process) Asynchronous Tasks With Django and Celery – Real Python

<https://realpython.com/asynchronous-tasks-with-django-and-celery/>

[\[4\]](https://severalnines.com/blog/vector-similarity-search-with-postgresqls-pgvector-a-deep-dive/#:~:text=Image%3A%20Image%20shows%20how%20vector,similarity%20search%20works) Vector Similarity Search with PostgreSQL’s pgvector - A Deep Dive | Severalnines

<https://severalnines.com/blog/vector-similarity-search-with-postgresqls-pgvector-a-deep-dive/>

[\[5\]](https://www.blog.pythonlibrary.org/2021/09/01/unit-conversion-pint/#:~:text=Do%20you%20need%20to%20work,Pint%20on%20their%20GitHub%20project) [\[8\]](https://www.blog.pythonlibrary.org/2021/09/01/unit-conversion-pint/#:~:text=One%20of%20Pint%E2%80%99s%20cool%20features,can%20do%20stuff%20like%20this) Unit Conversion with Python and the Pint Package - Mouse Vs Python

<https://www.blog.pythonlibrary.org/2021/09/01/unit-conversion-pint/>

[\[6\]](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/multi-container-applications-docker-compose#:~:text=The%20docker,compose%C2%A0up) Defining your multi-container application with docker-compose.yml - .NET | Microsoft Learn

<https://learn.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/multi-container-applications-docker-compose>

[\[7\]](https://sneharawat.medium.com/transport-logistics-route-optimization-180d7eb86f2d#:~:text=,VRPP) Transport Logistics | Route Optimization | by Sneha Rawat | Medium

<https://sneharawat.medium.com/transport-logistics-route-optimization-180d7eb86f2d>

[\[9\]](https://developer-ce.kroger.com/documentation/api-products/public/products/overview#:~:text=The%20Products%20API%20allows%20you,promo%20price%20of%20the%20item) Products API Overview - Kroger Developers

<https://developer-ce.kroger.com/documentation/api-products/public/products/overview>

[\[10\]](https://documenter.getpostman.com/view/4833726/TVReeWJm#:~:text=Kroger%20Public%20APIs%20Products,com%2Fv1%2Fproducts) Kroger Public APIs

<https://documenter.getpostman.com/view/4833726/TVReeWJm>

[\[11\]](https://scrapfly.io/blog/posts/guide-to-walmart-api#:~:text=In,as%20long%20as%20product) In-Depth Guide to the Walmart API - Scrapfly

<https://scrapfly.io/blog/posts/guide-to-walmart-api>

[\[12\]](https://www.reddit.com/r/learnprogramming/comments/1hmztg3/does_walmarts_api_allows_realtime_access_to_store/#:~:text=Does%20Walmart%27s%20API%20allows%20real,item%20listed%20as%20%E2%80%9Cin) Does Walmart's API allows real-time access to store inventory and ...

<https://www.reddit.com/r/learnprogramming/comments/1hmztg3/does_walmarts_api_allows_realtime_access_to_store/>

[\[13\]](https://developer.kroger.com/reference/api/location-api-public#:~:text=Location%20API%20,Locations%20API%20has%20a) Location API - Kroger Developers

<https://developer.kroger.com/reference/api/location-api-public>

[\[14\]](https://github.com/founded-labs/react-native-reusables#:~:text=Bringing%20shadcn%2Fui%20to%20React%20Native,almost%20as%20easy%20to%20use) GitHub - founded-labs/react-native-reusables: Bringing shadcn/ui to React Native. Beautifully crafted components with Nativewind, open source, and almost as easy to use.

<https://github.com/founded-labs/react-native-reusables>

[\[15\]](https://docs.expo.dev/router/introduction/#:~:text=) Introduction to Expo Router - Expo Documentation

<https://docs.expo.dev/router/introduction/>
